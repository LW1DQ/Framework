Vamos a dise√±ar una gu√≠a completa y detallada, dividida en etapas funcionales, para implementar el sistema A2A (Agentes Aut√≥nomos) descrito en el documento. La gu√≠a se basar√° en el contenido del documento y en mejores pr√°cticas para la construcci√≥n de sistemas multi-agente con las herramientas mencionadas (Ollama, LangGraph, NS-3, etc.).
Objetivo: Construir un sistema multi-agente aut√≥nomo (A2A) que investigue, simule, analice y redacte sobre protocolos de enrutamiento en ciudades inteligentes, utilizando herramientas de c√≥digo abierto y sin coste de suscripci√≥n.
Enfoque: Dividir la implementaci√≥n en etapas peque√±as y funcionales, de manera que cada etapa entregue un resultado probable y sirva de base para la siguiente.
Etapas de Implementaci√≥n:
Configuraci√≥n del Entorno y Herramientas B√°sicas
Preparar el sistema operativo (Ubuntu 22.04/24.04 recomendado).
Instalar Python 3.10+ y crear un entorno virtual.
Instalar Ollama y configurar modelos de lenguaje (Llama 3.1, DeepSeek-Coder, etc.).
Configurar Git y el repositorio del proyecto.
Configuraci√≥n del Entorno de Simulaci√≥n NS-3
Instalar dependencias de NS-3.
Compilar NS-3 con bindings de Python y el m√≥dulo ns3-ai.
Verificar la instalaci√≥n con ejemplos simples.
Desarrollo del Sistema Multi-Agente con LangGraph
Instalar LangGraph y dependencias.
Definir el estado global del sistema.
Implementar agentes b√°sicos (Investigador, Programador, Simulador).
Orquestar los agentes en un flujo de trabajo con LangGraph.
Integraci√≥n de Herramientas de An√°lisis y Visualizaci√≥n
Agregar agente de an√°lisis estad√≠stico (con SciPy y R).
Agregar agente de visualizaci√≥n (con Matplotlib y NetworkX).
Integrar el agente de an√°lisis de series temporales.
Automatizaci√≥n y Robustez
Implementar scripts de automatizaci√≥n (inicio, git, notificaciones).
Configurar la bit√°cora (logging) y manejo de errores.
Dockerizar el sistema para reproducibilidad.
Generaci√≥n de Documentos Acad√©micos
Implementar agentes de redacci√≥n (tesis y art√≠culos IEEE).
Gestionar referencias bibliogr√°ficas (BibTeX).
Integraci√≥n con Overleaf (opcional).
Despliegue y Ejecuci√≥n en la Nube (GitHub Actions)
Configurar GitHub Actions para ejecuci√≥n autom√°tica.
Gestionar secretos y variables de entorno.
Implementar notificaciones de resultados.
Pruebas y Validaci√≥n
Pruebas unitarias de cada agente.
Pruebas de integraci√≥n del flujo completo.
Validaci√≥n de resultados y documentos generados.
Vamos a desarrollar cada etapa con comandos y c√≥digo espec√≠fico, asegurando que cada paso sea funcional y probado.
Etapa 1: Configuraci√≥n del Entorno y Herramientas B√°sicas
Objetivo: Tener un entorno de desarrollo funcional con Ollama y los modelos de lenguaje necesarios.
Paso 1.1: Configuraci√≥n del Sistema Operativo
Se recomienda Ubuntu 22.04 o 24.04. Aseg√∫rate de tener al menos 16 GB de RAM y 100 GB de almacenamiento.
Paso 1.2: Instalaci√≥n de Python y Entorno Virtual
bash
sudo apt update
sudo apt install python3.10 python3.10-venv python3.10-dev git curl
# Crear un directorio para el proyecto
mkdir a2a_thesis
cd a2a_thesis
# Crear y activar entorno virtual
python3.10 -m venv a2a_env
source a2a_env/bin/activate
Paso 1.3: Instalaci√≥n de Ollama y Modelos
bash
# Instalar Ollama
curl -fsSL https://ollama.com/install.sh | sh
# Iniciar el servicio Ollama (se inicia autom√°ticamente despu√©s de la instalaci√≥n)
# Verificar que el servicio est√° corriendo
systemctl status ollama
# Descargar modelos de lenguaje
ollama pull llama3.1:8b
ollama pull deepseek-coder-v2
ollama pull nomic-embed-text-v1.5
# Verificar modelos
ollama list
Paso 1.4: Configuraci√≥n de Git
bash
git init
git config user.email "tu_email@ejemplo.com"
git config user.name "Tu Nombre"
# Crear .gitignore
echo "a2a_env/" >> .gitignore
echo "logs/" >> .gitignore
echo "*.db" >> .gitignore
echo "*.log" >> .gitignore
echo "__pycache__/" >> .gitignore
echo "*.pyc" >> .gitignore
git add .
git commit -m "Configuraci√≥n inicial del entorno"
Etapa 2: Configuraci√≥n del Entorno de Simulaci√≥n NS-3
Objetivo: Tener NS-3 compilado con los bindings de Python y el m√≥dulo ns3-ai.
Paso 2.1: Instalaci√≥n de Dependencias de NS-3
bash
sudo apt install g++ python3 python3-dev pkg-config sqlite3 cmake libgtk-3-dev libeigen3-dev libgsl-dev
Paso 2.2: Compilaci√≥n de NS-3
bash
# Descargar NS-3 (versi√≥n 3.40 o superior)
wget https://www.nsnam.org/releases/ns-allinone-3.40.tar.bz2
tar xjf ns-allinone-3.40.tar.bz2
cd ns-allinone-3.40/ns-3.40
# Configurar con bindings de Python
./ns3 configure --enable-python-bindings --enable-examples
# Compilar (puede tardar varios minutos)
./ns3 build
# Verificar la instalaci√≥n
./ns3 run hello-simulator
Paso 2.3: Instalaci√≥n de ns3-ai
bash
cd contrib
git clone https://github.com/hust-diangroup/ns3-ai.git
cd ..
./ns3 configure --enable-python-bindings
./ns3 build
# Instalar el m√≥dulo de Python
pip install ./contrib/ns3-ai/py_interface
Etapa 3: Desarrollo del Sistema Multi-Agente con LangGraph
Objetivo: Tener un flujo de trabajo b√°sico con agentes que investigan, generan c√≥digo y ejecutan simulaciones.
Paso 3.1: Instalaci√≥n de Dependencias de Python
bash
# Aseg√∫rate de estar en el entorno virtual
source a2a_env/bin/activate
pip install langgraph langchain langchain-community langchain-ollama chromadb pandas matplotlib semanticscholar
Paso 3.2: Definici√≥n del Estado Global
Crear¬†state.py:
python
from typing import TypedDict, List, Annotated, Optional
import operator
class AgentState(TypedDict):
    task: str
    research_notes: List[str]
    code_snippet: str
    simulation_logs: str
    analysis_report: str
    errors: List[str]
    iteration_count: int
    messages: Annotated[List[str], operator.add]
    statistical_results: Optional[dict]
    comparison_metrics: Optional[List[str]]
    plots_path: Optional[str]
Paso 3.3: Implementaci√≥n de Agentes B√°sicos
Crear¬†agents/researcher.py:
python
from langchain_community.tools.semanticscholar.tool import SemanticScholarQueryRun
from langchain_ollama import ChatOllama
from chromadb import Client
def research_node(state):
    print("--- AGENTE INVESTIGADOR: Buscando papers ---")
    topic = state['task']
    tool = SemanticScholarQueryRun()
    results = tool.run(f"routing protocols optimization {topic} ns-3")
    llm = ChatOllama(model="llama3.1", temperature=0)
    synthesis = llm.invoke(f"Resume los hallazgos clave para implementar en NS-3 basados en: {results}")
    # Almacenar en ChromaDB
    client = Client()
    collection = client.get_or_create_collection("thesis_papers")
    collection.add(documents=[synthesis.content], ids=[f"doc_{hash(topic)}"])
    return {"research_notes": [synthesis.content]}
Crear¬†agents/coder.py:
python
from langchain_ollama import ChatOllama
def coder_node(state):
    print("--- AGENTE PROGRAMADOR: Escribiendo script NS-3 ---")
    llm = ChatOllama(model="deepseek-coder-v2", temperature=0.1)
    prompt = f"""
    Eres un experto en NS-3 con Python. Genera un script completo de simulaci√≥n.
    Objetivo: {state['task']}
    Consideraciones de investigaci√≥n: {state['research_notes']}
    REGLAS:
    1. Usa 'import ns.applications', 'import ns.core', etc.
    2. Configura FlowMonitor para exportar estad√≠sticas a 'resultados.xml'.
    3. NO uses C++, solo Python.
    4. Devuelve SOLO el c√≥digo, sin markdown.
    """
    if state.get('errors'):
        prompt += f"\n\nCorrige el c√≥digo anterior bas√°ndote en este error: {state['errors'][-1]}"
    code = llm.invoke(prompt).content
    return {"code_snippet": code, "iteration_count": state['iteration_count'] + 1}
Crear¬†agents/simulator.py:
python
import subprocess
import os
def simulation_node(state):
    print("--- AGENTE SIMULADOR: Ejecutando NS-3 ---")
    code = state['code_snippet']
    ns3_dir = "ns-allinone-3.40/ns-3.40"
    filename = "scratch/tesis_sim.py"
    with open(f"{ns3_dir}/{filename}", "w") as f:
        f.write(code)
    try:
        result = subprocess.run(
            ["./ns3", "run", filename],
            cwd=ns3_dir,
            capture_output=True,
            text=True,
            timeout=600
        )
        if result.returncode != 0:
            return {"errors": [result.stderr]}
        return {"simulation_logs": f"{ns3_dir}/resultados.xml"}
    except Exception as e:
        return {"errors": [str(e)]}
Paso 3.4: Orquestaci√≥n con LangGraph
Crear¬†main_graph.py:
python
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
import sqlite3
from agents.researcher import research_node
from agents.coder import coder_node
from agents.simulator import simulation_node
from state import AgentState
workflow = StateGraph(AgentState)
workflow.add_node("investigador", research_node)
workflow.add_node("programador", coder_node)
workflow.add_node("simulador", simulation_node)
workflow.set_entry_point("investigador")
workflow.add_edge("investigador", "programador")
workflow.add_edge("programador", "simulador")
def check_simulation(state):
    if state.get('errors'):
        if state['iteration_count'] > 3:
            return END
        return "programador"
    return END
workflow.add_conditional_edges("simulador", check_simulation, {"programador": "programador", END: END})
memory = SqliteSaver(sqlite3.connect("bitacora_tesis.db"))
app = workflow.compile(checkpointer=memory)
Paso 3.5: Ejecuci√≥n del Sistema
Crear¬†main.py:
python
from main_graph import app
from uuid import uuid4
thread_id = str(uuid4())
config = {"configurable": {"thread_id": thread_id}}
inputs = {
    "task": "Comparar latencia entre AODV y OLSR en una red vehicular con 50 nodos",
    "iteration_count": 0
}
for event in app.stream(inputs, config=config):
    for key, value in event.items():
        print(f"Terminado paso: {key}")
Ejecutar:
bash
python main.py
Etapa 4: Integraci√≥n de Herramientas de An√°lisis y Visualizaci√≥n
Objetivo: Extender el sistema con agentes de an√°lisis estad√≠stico y visualizaci√≥n.
Paso 4.1: Agente de An√°lisis Estad√≠stico
Crear¬†agents/statistical_evaluator.py:
python
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns
import os
def statistical_evaluator_node(state):
    print("--- AGENTE EVALUADOR: Analizando m√©tricas estad√≠sticas ---")
    simulation_logs = state.get("simulation_logs", "")
    if not simulation_logs or not os.path.exists(simulation_logs):
        return {"errors": ["No se encontraron logs de simulaci√≥n para evaluar."]}
    try:
        # Asumimos que los logs son un CSV o XML parseable
        df = pd.read_csv(simulation_logs) if simulation_logs.endswith('.csv') else _parse_ns3_xml(simulation_logs)
        metrics = state.get("comparison_metrics", ["PDR", "latencia"])
        protocols = df["protocolo"].unique()
        results = {}
        plots_path = os.path.join(os.path.dirname(simulation_logs), "statistical_plots")
        os.makedirs(plots_path, exist_ok=True)
        for metric in metrics:
            if metric not in df.columns:
                continue
            # Test de normalidad (Shapiro-Wilk)
            normality = {proto: stats.shapiro(df[df["protocolo"] == proto][metric]) for proto in protocols}
            # Test de homogeneidad de varianzas (Levene)
            if len(protocols) > 1:
                _, p_var = stats.levene(*[df[df["protocolo"] == proto][metric] for proto in protocols])
            # Elegir test param√©trico o no param√©trico
            if all(p > 0.05 for p, _ in normality.values()):
                if len(protocols) == 2:
                    _, p_value = stats.ttest_ind(df[df["protocolo"] == protocols[0]][metric], df[df["protocolo"] == protocols[1]][metric])
                    test_name = "t-test"
                else:
                    _, p_value = stats.f_oneway(*[df[df["protocolo"] == proto][metric] for proto in protocols])
                    test_name = "ANOVA"
            else:
                if len(protocols) == 2:
                    _, p_value = stats.mannwhitneyu(df[df["protocolo"] == protocols[0]][metric], df[df["protocolo"] == protocols[1]][metric])
                    test_name = "Mann-Whitney U"
                else:
                    _, p_value = stats.kruskal(*[df[df["protocolo"] == proto][metric] for proto in protocols])
                    test_name = "Kruskal-Wallis"
            # Generar boxplot
            plot_path = os.path.join(plots_path, f"{metric}_comparison.png")
            _generate_boxplot(df, metric, "protocolo", plot_path)
            results[metric] = {
                "test": test_name,
                "p_value": p_value,
                "normality": normality,
                "homogeneity_p": p_var if len(protocols) > 1 else None,
                "plot": plot_path,
                "conclusion": _interpret_p_value(p_value, len(protocols))
            }
        return {
            "statistical_results": results,
            "plots_path": plots_path
        }
    except Exception as e:
        return {"errors": [f"Error en el agente evaluador: {str(e)}"]}
def _parse_ns3_xml(xml_path):
    # Implementar parsing de XML de NS-3 (ej: FlowMonitor)
    pass
def _generate_boxplot(df, metric, group_by, save_path):
    plt.figure(figsize=(10, 6))
    sns.boxplot(data=df, x=group_by, y=metric)
    plt.title(f"Comparaci√≥n de {metric} por protocolo")
    plt.savefig(save_path, dpi=300, bbox_inches='tight')
    plt.close()
def _interpret_p_value(p_value, num_groups):
    if p_value < 0.05:
        return f"Diferencias estad√≠sticamente significativas (p = {p_value:.4f})."
    else:
        return f"No hay diferencias significativas (p = {p_value:.4f})."
Paso 4.2: Integrar el Agente Evaluador en el Grafo
Modificar¬†main_graph.py:
python
from agents.statistical_evaluator import statistical_evaluator_node
workflow.add_node("evaluador_estadistico", statistical_evaluator_node)
# Conectar despu√©s del simulador
workflow.add_edge("simulador", "evaluador_estadistico")
workflow.add_edge("evaluador_estadistico", END)
Etapa 5: Automatizaci√≥n y Robustez
Objetivo: Implementar scripts de automatizaci√≥n, bit√°cora y manejo de errores.
Paso 5.1: Script de Inicio
Crear¬†start_system.sh:
bash
#!/bin/bash
PROJECT_DIR="/ruta/a/tu/proyecto"
LOG_DIR="$PROJECT_DIR/logs"
LOG_FILE="$LOG_DIR/$(date +%Y%m%d_%H%M%S).log"
TASK="$1"
mkdir -p "$LOG_DIR"
cd "$PROJECT_DIR" || exit 1
python3 main.py "$TASK" >> "$LOG_FILE" 2>&1
if [ $? -eq 0 ]; then
    echo "Simulaci√≥n completada: $TASK" >> "$LOG_FILE"
else
    echo "Error en la simulaci√≥n: $TASK" >> "$LOG_FILE"
    exit 1
fi
Dar permisos:
bash
chmod +x start_system.sh
Paso 5.2: Configuraci√≥n de Bit√°cora y Manejo de Errores
El sistema ya usa SqliteSaver para persistir el estado. Podemos extenderlo con logging m√°s detallado.
Etapa 6: Generaci√≥n de Documentos Acad√©micos
Objetivo: Implementar agentes que redacten secciones de tesis y art√≠culos en formato IEEE.
Paso 6.1: Agente de Redacci√≥n de Tesis
Crear¬†agents/ieee_thesis_writer.py:
python
from langchain_ollama import ChatOllama
from jinja2 import Template
import os
class IeeeThesisWriter:
    def __init__(self):
        self.llm = ChatOllama(model="llama3.1", temperature=0.3)
        self.template_path = "templates/ieee_thesis_template.md"
    def write_section(self, state, section_type):
        with open(self.template_path, "r") as f:
            template = Template(f.read())
        prompt = self._get_prompt_for_section(section_type, state)
        content = self.llm.invoke(prompt).content
        output = template.render(
            titulo=state.get("task", "An√°lisis de protocolos de enrutamiento"),
            autor="Diego RH",
            fecha=os.environ.get("DATE", "2025-11-23"),
            seccion=section_type.capitalize(),
            contenido=content
        )
        output_dir = state.get("output_dir", "tesis_secciones")
        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(output_dir, f"seccion_{section_type}.md")
        with open(output_path, "w") as f:
            f.write(output)
        return {
            "thesis_sections": {section_type: output_path},
            "analysis_report": f"Secci√≥n '{section_type}' generada en {output_path}"
        }
    def _get_prompt_for_section(self, section_type, state):
        # Implementar prompt espec√≠fico para cada secci√≥n
        pass
Paso 6.2: Integrar el Agente de Redacci√≥n
Modificar¬†main_graph.py:
python
from agents.ieee_thesis_writer import IeeeThesisWriter
thesis_writer = IeeeThesisWriter()
workflow.add_node("redactor_tesis", lambda state: thesis_writer.write_section(state, state.get("section_type", "introduccion")))
# Conectar despu√©s del evaluador estad√≠stico
workflow.add_edge("evaluador_estadistico", "redactor_tesis")
workflow.add_edge("redactor_tesis", END)
Etapa 7: Despliegue y Ejecuci√≥n en la Nube (GitHub Actions)
Objetivo: Configurar GitHub Actions para ejecutar el sistema autom√°ticamente.
Paso 7.1: Crear el Archivo de Workflow
Crear¬†.github/workflows/a2a_workflow.yml:
yaml
name: A2A System - Ejecuci√≥n Automatizada
on:
  workflow_dispatch:
    inputs:
      task:
        description: 'Tarea para el sistema A2A'
        required: true
        default: 'Comparar AODV vs GNN en escenario urbano con 50 nodos'
      section_type:
        description: 'Secci√≥n a redactar (ej: resultados, introduccion)'
        required: false
        default: 'resultados'
env:
  PYTHON_VERSION: '3.10'
jobs:
  setup_and_run:
    name: Configurar y Ejecutar Sistema A2A
    runs-on: ubuntu-22.04
    timeout-minutes: 60
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run A2A System
      run: |
        python main.py "${{ github.event.inputs.task }}"
Paso 7.2: Configurar Secretos (Opcional)
Si necesitas claves de API (por ejemplo, para Telegram), config√∫ralas en los secretos del repositorio.
Etapa 8: Pruebas y Validaci√≥n
Objetivo: Asegurar que cada agente y el flujo completo funcionan correctamente.
Paso 8.1: Pruebas Unitarias
Crear¬†test_researcher.py:
python
from agents.researcher import research_node
state = {
    "task": "Comparar AODV y OLSR en VANETs",
    "research_notes": []
}
result = research_node(state)
print(result)
Ejecutar pruebas similares para cada agente.
Paso 8.2: Pruebas de Integraci√≥n
Ejecutar el flujo completo con una tarea simple y verificar que se generan los resultados esperados.
Conclusi√≥n
Esta gu√≠a te llevar√° paso a paso through la implementaci√≥n de un sistema A2A completo para tu tesis doctoral. Cada etapa est√° dise√±ada para ser funcional y probada, de manera que puedas ir construyendo y validando el sistema de manera incremental.
Recuerda que el documento adjunto contiene m√°s detalles y expansiones (como el agente de series temporales, el agente de redacci√≥n de art√≠culos, etc.) que puedes incorporar siguiendo la misma metodolog√≠a.
¬°Buena suerte con tu tesis!
Gu√≠a Completa de Implementaci√≥n del Sistema A2A para Tesis Doctoral
Bas√°ndome en el documento proporcionado y en las mejores pr√°cticas actuales de sistemas multi-agente, he creado una gu√≠a estructurada en¬†8 etapas progresivas¬†para implementar tu sistema A2A completo.
üéØ Visi√≥n General del Proyecto
Objetivo Final: Sistema aut√≥nomo que investigue, simule, analice y documente protocolos de enrutamiento para ciudades inteligentes usando NS-3, Ollama y LangGraph.
Arquitectura: Patr√≥n Supervisor-Trabajador con agentes especializados orquestados por LangGraph.
üìã Plan de Implementaci√≥n por Etapas
Etapa 1: Configuraci√≥n del Entorno Base
*(Semana 1 - Fundamentos)*
1.1. Sistema Operativo y Dependencias
bash
# En Ubuntu 22.04/24.04
sudo apt update && sudo apt upgrade -y
sudo apt install python3.10 python3.10-venv python3.10-dev git curl wget build-essential cmake pkg-config sqlite3 libeigen3-dev libgsl-dev -y
1.2. Entorno Python Aislado
bash
mkdir a2a_thesis && cd a2a_thesis
python3.10 -m venv a2a_env
source a2a_env/bin/activate
# Crear estructura de proyecto
mkdir -p agents templates logs simulations documents
1.3. Motor de IA (Ollama)
bash
# Instalar Ollama
curl -fsSL https://ollama.com/install.sh | sh
# Modelos esenciales (optimizados para 2025)
ollama pull llama3.1:8b-q4
ollama pull deepseek-coder-v2:latest
ollama pull nomic-embed-text-v1.5:latest
# Verificar
ollama list
1.4. Control de Versiones
bash
git init
echo "a2a_env/" >> .gitignore
echo "logs/" >> .gitignore
echo "*.db" >> .gitignore
echo "__pycache__/" >> .gitignore
echo "ns-allinone-*/" >> .gitignore
git add .
git commit -m "Etapa 1: Entorno base configurado"
‚úÖ Verificaci√≥n: Ejecutar¬†ollama list¬†y ver 3 modelos descargados.
Etapa 2: Simulador NS-3 + ns3-ai
*(Semana 2-3 - N√∫cleo de Simulaci√≥n)*
2.1. Compilaci√≥n de NS-3
bash
# Descargar y compilar NS-3.45 (2025)
wget https://www.nsnam.org/releases/ns-allinone-3.45.tar.bz2
tar xjf ns-allinone-3.45.tar.bz2
cd ns-allinone-3.45/ns-3.45
# Configuraci√≥n optimizada
./ns3 configure --enable-python-bindings --enable-examples --build-profile=optimized
# Compilaci√≥n paralela
./ns3 build --jobs=$(nproc)
# Verificar
./ns3 run hello-simulator
2.2. Integraci√≥n ns3-ai
bash
cd contrib
git clone https://github.com/hust-diangroup/ns3-ai.git
cd ..
./ns3 configure --enable-python-bindings
./ns3 build
# Instalar bindings Python
pip install ./contrib/ns3-ai/py_interface
2.3. Script de Prueba B√°sica
Crear¬†scratch/test_basic.py:
python
import ns.core
import ns.network
def main():
    print("‚úÖ NS-3 Python bindings funcionando correctamente")
    ns.core.LogComponentEnable("UdpEchoClientApplication", ns.core.LOG_LEVEL_INFO)
    print("Simulador configurado - listo para agentes")
if __name__ == "__main__":
    main()
Ejecutar:¬†./ns3 run scratch/test_basic.py
‚úÖ Verificaci√≥n: Script ejecuta sin errores y muestra mensaje de confirmaci√≥n.
Etapa 3: Sistema Multi-Agente B√°sico
*(Semana 3-4 - N√∫cleo A2A)*
3.1. Dependencias Python
bash
pip install langgraph langchain langchain-community langchain-ollama chromadb pandas matplotlib seaborn semanticscholar
3.2. Estado Global del Sistema
Crear¬†state.py:
python
from typing import TypedDict, List, Annotated, Optional, Dict
import operator
class AgentState(TypedDict):
    # N√∫cleo del flujo
    task: str
    research_notes: List[str]
    code_snippet: str
    simulation_logs: str
    analysis_report: str
    errors: List[str]
    iteration_count: int
    messages: Annotated[List[str], operator.add]
    # Expansiones futuras
    statistical_results: Optional[Dict]
    comparison_metrics: Optional[List[str]]
    plots_path: Optional[str]
    current_agent: str
3.3. Agente Investigador B√°sico
Crear¬†agents/researcher.py:
python
from langchain_community.tools.semanticscholar.tool import SemanticScholarQueryRun
from langchain_ollama import ChatOllama
def research_node(state):
    print("üîç AGENTE INVESTIGADOR: Buscando literatura...")
    topic = state['task']
    tool = SemanticScholarQueryRun()
    try:
        results = tool.run(f"routing protocols optimization {topic} ns-3 2024 2025")
        llm = ChatOllama(model="llama3.1", temperature=0)
        synthesis_prompt = f"""
        Resume los hallazgos m√°s relevantes para implementar en NS-3:
        {results}
        Enf√≥cate en:
        - M√©tricas de rendimiento (PDR, latencia, throughput)
        - Configuraciones de simulaci√≥n
        - Limitaciones mencionadas
        """
        synthesis = llm.invoke(synthesis_prompt)
        return {"research_notes": [synthesis.content], "errors": []}
    except Exception as e:
        return {"errors": [f"Error en investigaci√≥n: {str(e)}"]}
3.4. Agente Programador B√°sico
Crear¬†agents/coder.py:
python
from langchain_ollama import ChatOllama
def coder_node(state):
    print("üíª AGENTE PROGRAMADOR: Generando c√≥digo NS-3...")
    llm = ChatOllama(model="deepseek-coder-v2", temperature=0.1)
    base_prompt = f"""
    Eres un experto en NS-3. Genera un script Python completo para:
    TAREA: {state['task']}
    CONTEXTO INVESTIGACI√ìN: {state.get('research_notes', ['Sin contexto'])}
    REQUISITOS:
    1. Usa solo bindings Python (import ns.core, ns.network, etc.)
    2. Incluye FlowMonitor para m√©tricas
    3. Exporta resultados a XML
    4. Maneja errores con try-catch
    5. Comenta el c√≥digo claramente
    Devuelve SOLO el c√≥digo Python sin markdown.
    """
    if state.get('errors'):
        base_prompt += f"\n\nCORRECCI√ìN REQUERIDA: {state['errors'][-1]}"
    code = llm.invoke(base_prompt).content
    # Limpiar c√≥digo si viene envuelto en markdown
    if "```python" in code:
        code = code.split("```python")[1].split("```")[0]
    elif "```" in code:
        code = code.split("```")[1].split("```")[0]
    return {
        "code_snippet": code.strip(),
        "iteration_count": state.get('iteration_count', 0) + 1
    }
3.5. Orquestaci√≥n B√°sica
Crear¬†main_graph.py:
python
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
import sqlite3
from state import AgentState
from agents.researcher import research_node
from agents.coder import coder_node
def create_workflow():
    workflow = StateGraph(AgentState)
    # Agregar nodos
    workflow.add_node("investigador", research_node)
    workflow.add_node("programador", coder_node)
    # Configurar flujo
    workflow.set_entry_point("investigador")
    workflow.add_edge("investigador", "programador")
    workflow.add_edge("programador", END)
    # Sistema de persistencia
    memory = SqliteSaver(sqlite3.connect("bitacora_a2a.db"))
    return workflow.compile(checkpointer=memory)
# Instancia global
app = create_workflow()
3.6. Script de Ejecuci√≥n
Crear¬†run_basic.py:
python
from main_graph import app
from uuid import uuid4
def run_basic_test():
    print("üöÄ INICIANDO SISTEMA A2A B√ÅSICO")
    thread_id = str(uuid4())
    config = {"configurable": {"thread_id": thread_id}}
    inputs = {
        "task": "Crear simulaci√≥n b√°sica de 10 nodos con protocolo AODV",
        "iteration_count": 0,
        "research_notes": [],
        "errors": []
    }
    print("üìù Tarea:", inputs["task"])
    print("‚è≥ Ejecutando...")
    try:
        for event in app.stream(inputs, config=config):
            for agent, result in event.items():
                print(f"‚úÖ {agent.upper()} completado")
                if 'research_notes' in result:
                    print(f"   üìö Notas: {result['research_notes'][0][:100]}...")
                if 'code_snippet' in result:
                    print(f"   üìÑ C√≥digo generado ({len(result['code_snippet'])} caracteres)")
        print("üéØ FLUJO B√ÅSICO COMPLETADO")
    except Exception as e:
        print(f"‚ùå Error: {e}")
if __name__ == "__main__":
    run_basic_test()
‚úÖ Verificaci√≥n: Ejecutar¬†python run_basic.py¬†y ver flujo investigador ‚Üí programador funcionando.
Etapa 4: Agente Simulador y Ejecuci√≥n NS-3
*(Semana 4-5 - Integraci√≥n Completa)*
4.1. Agente Simulador
Crear¬†agents/simulator.py:
python
import subprocess
import os
import tempfile
def simulation_node(state):
    print("üîÑ AGENTE SIMULADOR: Ejecutando en NS-3...")
    code = state.get('code_snippet', '')
    if not code:
        return {"errors": ["No hay c√≥digo para ejecutar"]}
    # Crear archivo temporal
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(code)
        temp_path = f.name
    try:
        ns3_dir = "ns-allinone-3.45/ns-3.45"
        # Ejecutar en NS-3
        result = subprocess.run(
            ["./ns3", "run", temp_path],
            cwd=ns3_dir,
            capture_output=True,
            text=True,
            timeout=300  # 5 minutos m√°ximo
        )
        # Limpiar archivo temporal
        os.unlink(temp_path)
        if result.returncode != 0:
            error_msg = f"NS-3 Error: {result.stderr}" if result.stderr else f"Exit code: {result.returncode}"
            return {"errors": [error_msg]}
        # Buscar archivos de resultados
        output_files = []
        for file in ["results.xml", "output.xml", "statistics.xml"]:
            if os.path.exists(os.path.join(ns3_dir, file)):
                output_files.append(file)
        return {
            "simulation_logs": output_files[0] if output_files else "simulation_completed",
            "errors": []
        }
    except subprocess.TimeoutExpired:
        os.unlink(temp_path)
        return {"errors": ["Timeout: Simulaci√≥n excedi√≥ 5 minutos"]}
    except Exception as e:
        if os.path.exists(temp_path):
            os.unlink(temp_path)
        return {"errors": [f"Error de ejecuci√≥n: {str(e)}"]}
4.2. Grafo Mejorado con Manejo de Errores
Actualizar¬†main_graph.py:
python
from agents.simulator import simulation_node
def create_workflow():
    workflow = StateGraph(AgentState)
    # Todos los nodos
    workflow.add_node("investigador", research_node)
    workflow.add_node("programador", coder_node)
    workflow.add_node("simulador", simulation_node)
    # Flujo principal
    workflow.set_entry_point("investigador")
    workflow.add_edge("investigador", "programador")
    workflow.add_edge("programador", "simulador")
    # L√≥gica de reintentos
    def should_retry(state):
        if state.get('errors') and state.get('iteration_count', 0) < 3:
            print(f"üîÑ Reintento {state['iteration_count']}/3")
            return "programador"
        return END
    workflow.add_conditional_edges("simulador", should_retry, {
        "programador": "programador",
        END: END
    })
    memory = SqliteSaver(sqlite3.connect("bitacora_a2a.db"))
    return workflow.compile(checkpointer=memory)
4.3. Script de Prueba Completa
Crear¬†run_complete.py:
python
from main_graph import app
from uuid import uuid4
import sys
def run_complete_simulation(task_description):
    print("üöÄ SISTEMA A2A COMPLETO")
    print("=" * 50)
    thread_id = str(uuid4())
    config = {"configurable": {"thread_id": thread_id}}
    inputs = {
        "task": task_description,
        "iteration_count": 0,
        "research_notes": [],
        "errors": []
    }
    print(f"üìù Tarea: {task_description}")
    print("‚è≥ Ejecutando flujo completo...")
    print("-" * 50)
    try:
        for event in app.stream(inputs, config=config):
            for agent, result in event.items():
                print(f"‚úÖ {agent.upper()} completado")
                if 'errors' in result and result['errors']:
                    print(f"   ‚ö†Ô∏è  Errores: {result['errors']}")
                if 'research_notes' in result:
                    print(f"   üìö Investigaci√≥n: {len(result['research_notes'])} notas")
                if 'code_snippet' in result:
                    lines = result['code_snippet'].count('\n')
                    print(f"   üìÑ C√≥digo: {lines} l√≠neas")
                if 'simulation_logs' in result:
                    print(f"   üìä Simulaci√≥n: {result['simulation_logs']}")
        print("-" * 50)
        print("üéØ FLUJO COMPLETADO EXITOSAMENTE")
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
        return False
    return True
if __name__ == "__main__":
    task = "Crear simulaci√≥n de red vehicular con 20 nodos usando protocolo AODV"
    if len(sys.argv) > 1:
        task = " ".join(sys.argv[1:])
    success = run_complete_simulation(task)
    sys.exit(0 if success else 1)
‚úÖ Verificaci√≥n: Ejecutar¬†python run_complete.py¬†y ver flujo completo investigador ‚Üí programador ‚Üí simulador.
Etapa 5: Agente Analizador y Evaluador
*(Semana 5-6 - An√°lisis Autom√°tico)*
5.1. Agente Analizador Estad√≠stico
Crear¬†agents/analyzer.py:
python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import os
import xml.etree.ElementTree as ET
def analysis_node(state):
    print("üìä AGENTE ANALIZADOR: Procesando resultados...")
    log_file = state.get('simulation_logs', '')
    if not log_file or not os.path.exists(log_file):
        return {"errors": [f"Archivo de logs no encontrado: {log_file}"]}
    try:
        # Parsear XML de NS-3 (ejemplo b√°sico)
        if log_file.endswith('.xml'):
            results = parse_ns3_xml(log_file)
        else:
            return {"analysis_report": "Simulaci√≥n completada (sin an√°lisis detallado)"}
        # Generar reporte b√°sico
        report = generate_basic_report(results)
        # Generar visualizaci√≥n simple
        plot_path = generate_visualization(results, log_file)
        return {
            "analysis_report": report,
            "plots_path": plot_path,
            "statistical_results": results
        }
    except Exception as e:
        return {"errors": [f"Error en an√°lisis: {str(e)}"]}
def parse_ns3_xml(xml_path):
    """Parseo b√°sico de XML de NS-3"""
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()
        # Extraer m√©tricas b√°sicas
        metrics = {}
        for flow in root.findall('.//Flow'):
            flow_id = flow.get('flowId', 'unknown')
            metrics[flow_id] = {
                'tx_packets': flow.find('txPackets').text if flow.find('txPackets') is not None else '0',
                'rx_packets': flow.find('rxPackets').text if flow.find('rxPackets') is not None else '0',
                'delay': flow.find('delaySum').text if flow.find('delaySum') is not None else '0'
            }
        return metrics
    except Exception:
        return {"raw_data": "XML parseado crudo"}
def generate_basic_report(results):
    """Generar reporte de an√°lisis b√°sico"""
    report = "# Reporte de An√°lisis de Simulaci√≥n\n\n"
    if isinstance(results, dict) and 'raw_data' not in results:
        total_flows = len(results)
        report += f"- **Total de flujos**: {total_flows}\n"
        for flow_id, metrics in list(results.items())[:5]:  # Primeros 5 flujos
            report += f"\n## Flujo {flow_id}\n"
            for metric, value in metrics.items():
                report += f"- {metric}: {value}\n"
    else:
        report += "Datos de simulaci√≥n procesados correctamente.\n"
    report += "\n## Recomendaciones\n"
    report += "- Verificar m√©tricas de PDR (Packet Delivery Ratio)\n"
    report += "- Analizar latencia por flujo\n"
    report += "- Considerar m√∫ltiples ejecuciones para estabilidad estad√≠stica\n"
    return report
def generate_visualization(results, log_file):
    """Generar visualizaci√≥n b√°sica"""
    plots_dir = "simulations/plots"
    os.makedirs(plots_dir, exist_ok=True)
    plot_path = os.path.join(plots_dir, "basic_analysis.png")
    # Ejemplo: gr√°fico simple de m√©tricas
    plt.figure(figsize=(10, 6))
    if isinstance(results, dict) and 'raw_data' not in results:
        flow_ids = list(results.keys())[:10]  # Primeros 10 flujos
        packet_counts = [
            int(results[flow_id].get('rx_packets', 0)) 
            for flow_id in flow_ids
        ]
        plt.bar(range(len(flow_ids)), packet_counts)
        plt.title('Paquetes Recibidos por Flujo')
        plt.xlabel('Flujo ID')
        plt.ylabel('Paquetes Recibidos')
    else:
        plt.text(0.5, 0.5, 'Datos de simulaci√≥n\nprocesados correctamente', 
                ha='center', va='center', transform=plt.gca().transAxes)
        plt.title('Resultados de Simulaci√≥n')
    plt.tight_layout()
    plt.savefig(plot_path, dpi=150, bbox_inches='tight')
    plt.close()
    return plot_path
5.2. Grafo Final con An√°lisis
Actualizar¬†main_graph.py:
python
from agents.analyzer import analysis_node
def create_workflow():
    workflow = StateGraph(AgentState)
    # Todos los nodos
    workflow.add_node("investigador", research_node)
    workflow.add_node("programador", coder_node)
    workflow.add_node("simulador", simulation_node)
    workflow.add_node("analizador", analysis_node)
    # Flujo completo
    workflow.set_entry_point("investigador")
    workflow.add_edge("investigador", "programador")
    workflow.add_edge("programador", "simulador")
    workflow.add_edge("simulador", "analizador")
    workflow.add_edge("analizador", END)
    # L√≥gica de reintentos mejorada
    def should_retry(state):
        errors = state.get('errors', [])
        iteration = state.get('iteration_count', 0)
        if errors and iteration < 3:
            print(f"üîÑ Reintento {iteration}/3 - Error: {errors[-1][:100]}...")
            return "programador"
        elif errors:
            print(f"‚ùå L√≠mite de reintentos alcanzado")
            return "analizador"  # Ir a an√°lisis incluso con errores
        return "analizador"
    workflow.add_conditional_edges("simulador", should_retry, {
        "programador": "programador",
        "analizador": "analizador"
    })
    memory = SqliteSaver(sqlite3.connect("bitacora_a2a.db"))
    return workflow.compile(checkpointer=memory)
‚úÖ Verificaci√≥n: Ejecutar flujo completo y ver reporte de an√°lisis generado.
Etapa 6: Sistema de Bit√°cora y Monitoreo
*(Semana 6 - Robustez)*
6.1. Script de Inicio Automatizado
Crear¬†start_system.sh:
bash
#!/bin/bash
# start_system.sh - Sistema A2A Automatizado
PROJECT_DIR=$(pwd)
LOG_DIR="$PROJECT_DIR/logs"
CONFIG_FILE="$PROJECT_DIR/a2a_config.env"
# Configuraci√≥n
source $CONFIG_FILE 2>/dev/null || {
    echo "‚ö†Ô∏è  Creando configuraci√≥n por defecto..."
    cat > $CONFIG_FILE << EOF
MAX_RETRIES=3
TASK_DEFAULT="Simular protocolo AODV en red de 50 nodos"
LOG_LEVEL="INFO"
EOF
}
# Crear directorios
mkdir -p $LOG_DIR
# Funci√≥n de logging
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_DIR/a2a_system.log"
}
# Funci√≥n principal
run_a2a() {
    local task="${1:-$TASK_DEFAULT}"
    local log_file="$LOG_DIR/run_$(date +%Y%m%d_%H%M%S).log"
    log "üöÄ Iniciando sistema A2A"
    log "üìù Tarea: $task"
    cd $PROJECT_DIR
    source a2a_env/bin/activate
    # Ejecutar con timeout
    timeout 1h python run_complete.py "$task" >> "$log_file" 2>&1
    if [ $? -eq 0 ]; then
        log "‚úÖ Ejecuci√≥n completada - Ver log: $(basename $log_file)"
    else
        log "‚ùå Error en ejecuci√≥n - Ver log: $(basename $log_file)"
    fi
}
# Manejo de argumentos
case "${1:-}" in
    "test")
        run_a2a "Prueba b√°sica de sistema con 5 nodos"
        ;;
    "")
        run_a2a "$TASK_DEFAULT"
        ;;
    *)
        run_a2a "$*"
        ;;
esac
6.2. Configuraci√≥n B√°sica
Crear¬†a2a_config.env:
bash
# Configuraci√≥n Sistema A2A
MAX_RETRIES=3
TASK_DEFAULT="Simular comparaci√≥n de AODV y OLSR en red vehicular con 30 nodos"
LOG_LEVEL="INFO"
PYTHONPATH="./"
6.3. Verificaci√≥n de Salud del Sistema
Crear¬†check_system.py:
python
import subprocess
import sys
import os
def check_system():
    print("üîç Verificando salud del sistema A2A...")
    checks = {
        "Python environment": lambda: sys.executable.endswith("a2a_env/bin/python"),
        "Ollama running": lambda: subprocess.run(["curl", "-s", "http://localhost:11434/api/tags"], 
                                               capture_output=True).returncode == 0,
        "NS-3 compiled": lambda: os.path.exists("ns-allinone-3.45/ns-3.45/ns3"),
        "Dependencies installed": lambda: subprocess.run([sys.executable, "-c", "import langgraph, langchain_ollama"], 
                                                       capture_output=True).returncode == 0
    }
    all_ok = True
    for check_name, check_func in checks.items():
        try:
            if check_func():
                print(f"‚úÖ {check_name}")
            else:
                print(f"‚ùå {check_name}")
                all_ok = False
        except Exception as e:
            print(f"‚ùå {check_name}: {e}")
            all_ok = False
    if all_ok:
        print("\nüéØ Sistema listo para ejecuci√≥n")
    else:
        print("\n‚ö†Ô∏è  Sistema requiere configuraci√≥n adicional")
    return all_ok
if __name__ == "__main__":
    check_system()
‚úÖ Verificaci√≥n: Ejecutar¬†python check_system.py¬†y¬†chmod +x start_system.sh && ./start_system.sh test
Etapa 7: Expansiones Avanzadas
*(Semanas 7-8 - Caracter√≠sticas Doctorales)*
7.1. Agente Evaluador Estad√≠stico Avanzado
Crear¬†agents/advanced_analyzer.py¬†(basado en el contenido del documento):
python
# Implementar tests estad√≠sticos con SciPy, an√°lisis comparativo, etc.
# Usar el c√≥digo proporcionado en la secci√≥n "Agente Evaluador con SciPy"
7.2. Sistema de Reportes Automatizados
python
# Implementar generaci√≥n de reportes en LaTeX/Markdown
# Basado en la secci√≥n "Agentes de Redacci√≥n para Documentos IEEE"
7.3. Dashboard de Monitoreo B√°sico
Crear¬†monitor/dashboard.py¬†con Streamlit o Flask para visualizar el progreso.
Etapa 8: Integraci√≥n y Producci√≥n
*(Semanas 9-10 - Sistema Final)*
8.1. GitHub Actions para CI/CD
Crear¬†.github/workflows/a2a_tests.yml¬†para pruebas autom√°ticas.
8.2. Documentaci√≥n Completa
Crear¬†README.md¬†con instrucciones de instalaci√≥n y uso.
8.3. Script de Despliegue
Crear¬†deploy.sh¬†para configuraci√≥n autom√°tica en nuevos entornos.
üìä M√©tricas de Progreso
GUIA DE USUARIO
¬°Perfecto! Vamos a crear una gu√≠a de uso completa para los miembros del grupo de investigaci√≥n que vayan a utilizar el sistema A2A. La gu√≠a debe ser clara, paso a paso, y asumir que los usuarios tienen diferentes niveles de experiencia t√©cnica.
Gu√≠a de Usuario del Sistema A2A para el Grupo de Investigaci√≥n
üìã Tabla de Contenidos
Requisitos Previos
Instalaci√≥n R√°pida
Configuraci√≥n Inicial
Uso B√°sico del Sistema
Ejemplos de Tareas Comunes
Monitoreo y Resultados
Soluci√≥n de Problemas
Mejores Pr√°cticas
üõ† Requisitos Previos
Hardware M√≠nimo
Sistema Operativo: Ubuntu 22.04/24.04 (recomendado) o Windows WSL2
RAM: 16 GB (m√≠nimo), 32 GB (recomendado)
Almacenamiento: 100 GB de espacio libre
CPU: 4 n√∫cleos (m√≠nimo), 8+ n√∫cleos (recomendado)
GPU: Opcional (acelera inferencia de modelos grandes)
Software Requerido
Git
Python 3.10+
Curl/Wget
üöÄ Instalaci√≥n R√°pida
Paso 1: Clonar el Repositorio
bash
git clone https://github.com/tu_usuario/a2a-thesis-system.git
cd a2a-thesis-system
Paso 2: Ejecutar Instalador Autom√°tico
bash
# Este script instala todo autom√°ticamente
chmod +x install_system.sh
./install_system.sh
¬øQu√© hace el instalador?
Crea entorno virtual Python
Instala Ollama y modelos base
Compila NS-3 con soporte AI
Instala dependencias Python
Configura variables de entorno
Paso 3: Verificar Instalaci√≥n
bash
python check_system.py
‚úÖ Deber√≠as ver todas las marcas verdes si la instalaci√≥n fue exitosa.
‚öôÔ∏è Configuraci√≥n Inicial
Archivo de Configuraci√≥n
Edita¬†a2a_config.env¬†seg√∫n tus necesidades:
bash
# Configuraci√≥n Principal
TASK_DEFAULT="Simular protocolo AODV en red de 50 nodos"
MAX_RETRIES=3
LOG_LEVEL="INFO"
# Rutas importantes
NS3_DIR="./ns-allinone-3.45/ns-3.45"
OUTPUT_DIR="./simulations"
Modelos de IA Disponibles
El sistema viene preconfigurado con:
llama3.1:8b-q4: Razonamiento general
deepseek-coder-v2: Generaci√≥n de c√≥digo
nomic-embed-text-v1.5: B√∫squeda sem√°ntica
Para agregar m√°s modelos:
bash
ollama pull nombre_del_modelo
üéØ Uso B√°sico del Sistema
M√©todo 1: Interfaz de L√≠nea de Comandos (Recomendado)
Ejecuci√≥n Simple
bash
# Usar tarea por defecto
./start_system.sh
# Ejecutar tarea espec√≠fica
./start_system.sh "Comparar AODV y OLSR en red vehicular con 100 nodos"
# Modo prueba
./start_system.sh test
Ejecuci√≥n Avanzada
bash
# Ejecutar con log detallado
./start_system.sh "Tu tarea aqu√≠" 2>&1 | tee simulation.log
# Ejecutar en segundo plano
nohup ./start_system.sh "Tarea larga" > simulation.log 2>&1 &
M√©todo 2: Python Directo
bash
# Ejecutar flujo completo
python run_complete.py "Tu tarea de investigaci√≥n"
# Solo investigaci√≥n y generaci√≥n de c√≥digo
python run_basic.py "Tarea espec√≠fica"
M√©todo 3: Interfaz Web (Opcional)
bash
# Iniciar dashboard Streamlit
streamlit run monitor/dashboard.py
# Iniciar interfaz Flask
python monitor/web_interface.py
üìö Ejemplos de Tareas Comunes
Ejemplo 1: Comparaci√≥n de Protocolos B√°sica
bash
./start_system.sh "Comparar AODV, OLSR y DSDV en escenario urbano con 50 nodos m√≥viles durante 300 segundos. Evaluar PDR, latencia y overhead."
Ejemplo 2: An√°lisis de Escalabilidad
bash
./start_system.sh "Analizar escalabilidad de GNN vs AODV con 50, 100 y 200 nodos. Focus en throughput y consumo de memoria."
Ejemplo 3: Investigaci√≥n Espec√≠fica
bash
./start_system.sh "Investigar t√©cnicas de optimizaci√≥n de enrutamiento para VANETs en ciudades inteligentes. Generar c√≥digo NS-3 para simular movilidad vehicular realista."
Ejemplo 4: Validaci√≥n Estad√≠stica
bash
./start_system.sh "Ejecutar 10 r√©plicas de simulaci√≥n AODV vs OLSR con diferentes semillas. Aplicar tests estad√≠sticos para validar significancia de diferencias en PDR."
üìä Monitoreo y Resultados
Estructura de Resultados
text
a2a-thesis-system/
‚îú‚îÄ‚îÄ simulations/
‚îÇ   ‚îú‚îÄ‚îÄ plots/           # Gr√°ficos generados
‚îÇ   ‚îú‚îÄ‚îÄ results/         # Datos crudos
‚îÇ   ‚îî‚îÄ‚îÄ reports/         # Reportes autom√°ticos
‚îú‚îÄ‚îÄ logs/
‚îÇ   ‚îú‚îÄ‚îÄ a2a_system.log   # Log principal
‚îÇ   ‚îî‚îÄ‚îÄ run_YYYYMMDD_HHMMSS.log  # Logs por ejecuci√≥n
‚îî‚îÄ‚îÄ bitacora_a2a.db      # Base de datos de bit√°cora
C√≥mo Ver Resultados
Logs en Tiempo Real
bash
# Seguir log principal
tail -f logs/a2a_system.log
# Ver log espec√≠fico
less logs/run_20241123_143022.log
Resultados de Simulaci√≥n
bash
# Listar resultados recientes
ls -la simulations/results/
# Ver reporte generado
cat simulations/reports/latest_report.md
Visualizaci√≥n de Gr√°ficos
bash
# Los gr√°ficos se guardan en:
ls simulations/plots/
# Para ver gr√°ficos (requiere visor de im√°genes)
eog simulations/plots/basic_analysis.png
Acceso a la Bit√°cora
bash
# Explorar base de datos de bit√°cora
sqlite3 bitacora_a2a.db "SELECT * FROM checkpoints ORDER BY timestamp DESC LIMIT 10;"
üêõ Soluci√≥n de Problemas
Problemas Comunes y Soluciones
1. Error: "Ollama no est√° ejecut√°ndose"
bash
# Iniciar Ollama manualmente
ollama serve &
# Verificar
curl http://localhost:11434/api/tags
2. Error: "NS-3 no encontrado"
bash
# Recompilar NS-3
cd ns-allinone-3.45/ns-3.45
./ns3 configure --enable-python-bindings
./ns3 build
3. Error de Memoria Insuficiente
bash
# Usar modelos m√°s peque√±os
ollama pull llama3.1:8b-q4
# O configurar offloading a CPU
export OLLAMA_NUM_GPU=0
4. Timeout en Simulaciones Largas
bash
# Aumentar timeout en agents/simulator.py
timeout=600  # 10 minutos en lugar de 300
Comandos de Diagn√≥stico
Verificar Salud del Sistema
bash
python check_system.py
Verificar Modelos Ollama
bash
ollama list
curl http://localhost:11434/api/generate -d '{
  "model": "llama3.1", 
  "prompt": "Test"
}'
Probar NS-3
bash
cd ns-allinone-3.45/ns-3.45
./ns3 run scratch/test_basic.py
Recuperaci√≥n de Errores
Reinicio Completo
bash
# Detener servicios
pkill -f ollama
pkill -f "python.*a2a"
# Limpiar y reiniciar
./clean_system.sh
./start_system.sh
Recuperar desde Bit√°cora
bash
# Ver √∫ltimos estados guardados
python scripts/recover_from_checkpoint.py
üí° Mejores Pr√°cticas
Para Usuarios Nuevos
Comienza con Tareas Peque√±as
bash
./start_system.sh test
./start_system.sh "Simulaci√≥n peque√±a con 10 nodos"
Verifica Resultados Paso a Paso
Revisa logs despu√©s de cada ejecuci√≥n
Confirma que se generen gr√°ficos y reportes
Valida el c√≥digo NS-3 generado
Usa Tareas Espec√≠ficas
‚ùå "Simular redes"
‚úÖ "Comparar PDR de AODV y OLSR con 30 nodos en 200x200m por 200 segundos"
Para Usuarios Avanzados
Personalizaci√≥n de Agentes
Edita¬†agents/researcher.py¬†para modificar b√∫squedas
Ajusta¬†agents/coder.py¬†para estilos de c√≥digo espec√≠ficos
Configuraci√≥n de Modelos
bash
# Usar modelos m√°s grandes (si hay recursos)
ollama pull llama3.1:70b
# Modelos especializados
ollama pull codellama:34b
Automatizaci√≥n Avanzada
bash
# Ejecutar m√∫ltiples tareas
for task in "tarea1" "tarea2" "tarea3"; do
    ./start_system.sh "$task"
done
Mantenimiento del Sistema
Actualizaciones Regulares
bash
# Actualizar c√≥digo
git pull origin main
# Actualizar modelos Ollama
ollama pull llama3.1
ollama pull deepseek-coder-v2
# Reinstalar dependencias Python
pip install -r requirements.txt --upgrade
Limpieza Peri√≥dica
bash
# Limpiar logs antiguos (>30 d√≠as)
find logs/ -name "*.log" -mtime +30 -delete
# Limpiar simulaciones antiguas
find simulations/ -name "*.xml" -mtime +7 -delete
Backup de Resultados Importantes
bash
# Backup de bit√°cora y resultados
tar -czf backup_$(date +%Y%m%d).tar.gz bitacora_a2a.db simulations/results/
üÜò Soporte y Recursos
Canales de Ayuda
Documentaci√≥n:¬†docs/¬†directory en el repositorio
Ejemplos:¬†examples/¬†directory con casos de uso
Issues: GitHub Issues para reportar bugs
Wiki: Documentaci√≥n colaborativa en GitHub Wiki
Comandos de Ayuda Integrados
bash
# Mostrar ayuda del sistema
python -m a2a_system --help
# Ver versi√≥n y estado
python check_system.py --verbose
# Generar reporte de diagn√≥stico
python scripts/diagnostic_report.py
Escalaci√≥n de Problemas
Si encuentras problemas:
Revisa logs:¬†logs/a2a_system.log
Ejecuta diagn√≥stico:¬†python check_system.py
Consulta issues conocidos: GitHub Issues
Contacta al administrador: [tu_email@universidad.edu]
üîÑ Flujo de Trabajo Recomendado
Para Investigadores
Planificaci√≥n: Define tarea espec√≠fica con m√©tricas claras
Ejecuci√≥n: Usa¬†./start_system.sh "tarea espec√≠fica"
Validaci√≥n: Revisa logs y resultados intermedios
An√°lisis: Examina reportes y gr√°ficos generados
Iteraci√≥n: Refina tarea basado en resultados
Para Desarrolladores
Extensi√≥n: Agrega nuevos agentes en¬†agents/
Pruebas: Usa¬†./start_system.sh test
Integraci√≥n: Actualiza¬†main_graph.py
Documentaci√≥n: Actualiza esta gu√≠a
üìû Contacto y Contribuciones
Mantenedores del Sistema
Responsable: [Tu Nombre]
Contacto: [tu_email@universidad.edu]
Horario de Soporte: [Lunes-Viernes 9:00-18:00]
C√≥mo Contribuir
Fork el repositorio
Crea una rama para tu feature
Haz commit de tus cambios
Abre un Pull Request
Reportar Problemas
Al reportar un problema, incluye:
Comando exacto ejecutado
Logs relevantes
Salida de¬†python check_system.py
Descripci√≥n del comportamiento esperado vs actual
¬øTe gustar√≠a que agregue alguna secci√≥n espec√≠fica o profundice en alg√∫n aspecto particular de la gu√≠a de usuario?
üéØ Gu√≠a de Usuario Completa - Sistema A2A para Investigaci√≥n
üìñ Tabla de Contenidos
Introducci√≥n R√°pida
Instalaci√≥n en 5 Minutos
Primer Uso - Prueba R√°pida
Flujos de Trabajo Comunes
Ejemplos Paso a Paso
Soluci√≥n de Problemas Comunes
Recursos Adicionales
üöÄ Introducci√≥n R√°pida
¬øQu√© es el Sistema A2A?
Un¬†equipo de investigaci√≥n aut√≥nomo¬†que te ayuda a:
üîç¬†Investigar¬†literatura autom√°ticamente
üíª¬†Generar c√≥digo¬†de simulaci√≥n NS-3
üéØ¬†Ejecutar simulaciones¬†complejas
üìä¬†Analizar resultados¬†estad√≠sticamente
üìù¬†Documentar hallazgos¬†en formato acad√©mico
Arquitectura Sencilla
text
Entrada ‚Üí [Investigador] ‚Üí [Programador] ‚Üí [Simulador] ‚Üí [Analizador] ‚Üí Salidas
‚ö° Instalaci√≥n en 5 Minutos
Paso 1: Clonar y Configurar
bash
# Clonar el repositorio
git clone https://github.com/tu-usuario/a2a-thesis-system.git
cd a2a-thesis-system
# Ejecutar instalador autom√°tico
chmod +x setup.sh
./setup.sh
Paso 2: Verificar Instalaci√≥n
bash
# Verificar que todo est√© listo
python check_installation.py
# Salida esperada:
# ‚úÖ Python environment ready
# ‚úÖ Ollama models loaded  
# ‚úÖ NS-3 compiled
# ‚úÖ Dependencies installed
Paso 3: Configuraci√≥n B√°sica
bash
# Editar configuraci√≥n b√°sica (opcional)
nano config/basic_config.yaml
Configuraci√≥n m√≠nima recomendada:
yaml
system:
  max_retries: 3
  timeout_minutes: 60
models:
  research: "llama3.1"
  coding: "deepseek-coder-v2"
paths:
  output_dir: "./mis_resultados"
  logs_dir: "./mis_logs"
üéØ Primer Uso - Prueba R√°pida
Ejecutar Demo de Validaci√≥n
bash
# Ejecutar prueba de concepto (5-10 minutos)
python run_demo.py --test quick
# O usar el script simplificado
./quick_test.sh
Verificar Resultados
bash
# Ver logs generados
tail -f mis_logs/demo_quick.log
# Ver resultados
ls -la mis_resultados/demo/
Tu Primera Tarea Real
bash
# Ejemplo simple para empezar
python run_system.py --task "Simular 10 nodos con AODV y calcular PDR"
üîÑ Flujos de Trabajo Comunes
1. üîç Flujo de Investigaci√≥n R√°pida
bash
# Solo investigaci√≥n bibliogr√°fica
python run_research.py --query "optimizaci√≥n enrutamiento VANETs 2024"
# Guardar resultados para usar despu√©s
python run_research.py --query "GNN routing protocols" --save research_notes.json
2. üíª Flujo de Generaci√≥n de C√≥digo
bash
# Generar c√≥digo basado en investigaci√≥n previa
python run_coder.py --input research_notes.json --task "implementar AODV"
# Generar c√≥digo espec√≠fico
python run_coder.py --task "crear simulaci√≥n MANET con 50 nodos m√≥viles"
3. üéØ Flujo de Simulaci√≥n Completa
bash
# Ejecutar todo el pipeline
python run_complete.py --task "Comparar AODV vs OLSR en escenario urbano"
# Con par√°metros espec√≠ficos
python run_complete.py \
  --task "Simular red vehicular con congesti√≥n" \
  --nodes 100 \
  --time 300 \
  --protocols AODV,OLSR,GNN
4. üìä Flujo de An√°lisis
bash
# Analizar resultados existentes
python run_analysis.py --input simulations/results.xml --metrics PDR,latency,throughput
# Comparar m√∫ltiples simulaciones
python run_analysis.py --compare sim1.xml sim2.xml sim3.xml
üìù Ejemplos Paso a Paso
Ejemplo 1: Comparaci√≥n B√°sica de Protocolos
Paso 1: Definir la tarea
bash
python run_system.py --task "Comparar AODV y OLSR en red de 30 nodos durante 200 segundos. M√©tricas: PDR, latencia, overhead."
Paso 2: Monitorear progreso
bash
# En otra terminal, ver logs en tiempo real
tail -f mis_logs/latest_simulation.log
# Ver progreso de agentes
python monitor_progress.py
Paso 3: Revisar resultados
bash
# Los resultados estar√°n en:
ls mis_resultados/comparacion_protocolos/
# Ver reporte autom√°tico
cat mis_resultados/comparacion_protocolos/analysis_report.md
# Ver gr√°ficos generados
ls mis_resultados/comparacion_protocolos/plots/
Ejemplo 2: Investigaci√≥n + Simulaci√≥n
Paso 1: Investigar el estado del arte
bash
python run_research.py \
  --query "machine learning routing VANETs 2024" \
  --save vanet_ml_research.json
Paso 2: Generar simulaci√≥n basada en investigaci√≥n
bash
python run_complete.py \
  --task "Implementar sistema de enrutamiento con ML basado en investigaci√≥n reciente" \
  --research vanet_ml_research.json \
  --output ml_routing_simulation
Paso 3: Analizar resultados espec√≠ficos
bash
python run_analysis.py \
  --input ml_routing_simulation/results.xml \
  --focus "machine learning performance" \
  --output ml_analysis_report.md
Ejemplo 3: An√°lisis Estad√≠stico Avanzado
Paso 1: Ejecutar m√∫ltiples r√©plicas
bash
for i in {1..5}; do
  python run_complete.py \
    --task "Simulaci√≥n AODV con semilla $i" \
    --seed $i \
    --output replica_$i
done
Paso 2: An√°lisis comparativo
bash
python run_advanced_analysis.py \
  --input replica_1 replica_2 replica_3 replica_4 replica_5 \
  --statistical-tests anova,kruskal \
  --output statistical_comparison
Paso 3: Generar reporte acad√©mico
bash
python generate_report.py \
  --analysis statistical_comparison \
  --format ieee \
  --output paper_draft.tex
üõ† Uso Avanzado
Configuraci√≥n de Modelos Espec√≠ficos
bash
# Usar modelos diferentes para diferentes tareas
python run_system.py \
  --task "An√°lisis complejo de performance" \
  --research-model "llama3.1:70b" \
  --coding-model "deepseek-coder-v2:latest" \
  --analysis-model "llama3.1"
Par√°metros de Simulaci√≥n
bash
python run_complete.py \
  --task "Simulaci√≥n personalizada" \
  --nodes 50 \
  --simulation-time 600 \
  --area "1000x1000" \
  --mobility "random-waypoint" \
  --protocols "AODV,OLSR,DSR" \
  --metrics "PDR,latency,throughput,overhead"
Integraci√≥n con Herramientas Existentes
bash
# Usar datos existentes
python run_analysis.py --input mis_propios_datos.csv --format custom
# Exportar a formatos comunes
python export_results.py --input resultados.xml --format csv,json,latex
‚ùó Soluci√≥n de Problemas Comunes
Problema: "Ollama no responde"
bash
# Soluci√≥n r√°pida
./scripts/restart_ollama.sh
# Verificar estado
curl http://localhost:11434/api/tags
# Reiniciar servicio
ollama serve &
Problema: "NS-3 no encuentra bibliotecas"
bash
# Reconfigurar NS-3
cd ns-allinone-3.45/ns-3.45
./ns3 configure --enable-python-bindings
./ns3 build
Problema: "Memoria insuficiente"
bash
# Usar modelos m√°s peque√±os
python run_system.py --research-model "llama3.1:8b" --coding-model "deepseek-coder:7b"
# Limpiar cach√©
./scripts/clean_cache.sh
Problema: "Timeout en simulaciones largas"
bash
# Aumentar tiempo de espera
python run_complete.py --task "Mi simulaci√≥n" --timeout 120
# Ejecutar en partes
python run_research.py --task "Parte 1: Investigaci√≥n"
python run_coder.py --task "Parte 2: Generar c√≥digo"
python run_simulator.py --task "Parte 3: Ejecutar simulaci√≥n"
Comandos de Diagn√≥stico
bash
# Verificar salud del sistema
python diagnostics.py --full
# Ver logs de errores
tail -f mis_logs/error.log
# Ver uso de recursos
./scripts/system_status.sh
üìö Recursos Adicionales
Scripts de Utilidad
bash
# Backup de resultados importantes
./scripts/backup_results.sh mi_experimento_importante
# Limpieza autom√°tica
./scripts/clean_old_results.sh --keep-last 10
# Estad√≠sticas de uso
./scripts/usage_stats.sh
Plantillas de Tareas
bash
# Usar plantillas predefinidas
python run_system.py --template vanet_comparison
python run_system.py --template scalability_analysis
python run_system.py --template qos_evaluation
Configuraciones Espec√≠ficas por Proyecto
yaml
# config/mi_proyecto.yaml
project: "Tesis_VANETs"
author: "Tu Nombre"
default_parameters:
  nodes: 100
  simulation_time: 300
  protocols: ["AODV", "OLSR", "GNN"]
preferred_models:
  research: "llama3.1"
  coding: "deepseek-coder-v2"
bash
# Usar configuraci√≥n espec√≠fica
python run_system.py --config config/mi_proyecto.yaml --task "Mi experimento"
üéì Para Miembros Nuevos del Grupo
Onboarding R√°pido (30 minutos)
Minuto 0-10: Instalaci√≥n
bash
git clone https://github.com/tu-usuario/a2a-thesis-system.git
cd a2a-thesis-system
./setup.sh
Minuto 10-20: Prueba b√°sica
bash
python run_demo.py --test quick
Minuto 20-30: Tu primera tarea real
bash
python run_system.py --task "Simular 20 nodos con AODV"
Checklist de Primer Uso
Sistema instalado sin errores
Prueba r√°pida ejecutada correctamente
Resultados b√°sicos generados
Logs revisados sin errores cr√≠ticos
Configuraci√≥n personalizada guardada
üîÑ Flujo de Trabajo Recomendado
Para Investigadores Principales
bash
# 1. Planificaci√≥n
python plan_experiment.py --hypothesis "El protocolo X mejora Y en Z condiciones"
# 2. Ejecuci√≥n automatizada
python run_complete.py --task "Validar hip√≥tesis: X vs Y en condiciones Z"
# 3. Revisi√≥n de resultados
python review_results.py --experiment ultima_simulacion --generate-report
Para Asistentes de Investigaci√≥n
bash
# Tareas espec√≠ficas y monitoreadas
python run_assistant.py --task "Ejecutar 10 r√©plicas de simulaci√≥n A" --supervised
# An√°lisis preliminares
python quick_analysis.py --input datos_brutos --output analisis_preliminar
Para Colaboradores Externos
bash
# Modo solo an√°lisis (sin acceso completo)
python analyze_only.py --input datos_proporcionados --format csv
# Generar reportes compartibles
python export_for_sharing.py --input resultados --format pdf,html
üìû Soporte y Contacto
Canales de Ayuda
Documentaci√≥n:¬†docs/guia_rapida.md
Ejemplos:¬†examples/¬†directory
Soporte T√©cnico: [tu-email@universidad.edu]
Issues: GitHub Issues del repositorio
Comandos de Ayuda Integrados
bash
# Ayuda general
python run_system.py --help
# Ayuda espec√≠fica por m√≥dulo
python run_research.py --help
python run_analysis.py --help
# Ver ejemplos de uso
python show_examples.py --category "vanet"
Estado del Sistema
bash
# Verificar disponibilidad
python system_status.py
# Ver uso actual
python resource_monitor.py
# Ver historial de ejecuciones
python execution_history.py --last 10
üéâ ¬°Listo para Empezar!
Tu Pr√≥ximo Paso Recomendado:
bash
# Ejecuta esto ahora mismo:
python run_quickstart.py
# O si prefieres control total:
python run_system.py --task "Mi primer experimento con el sistema A2A"
¬øPreguntas?
Revisa¬†docs/faq.md¬†para preguntas frecuentes
Usa¬†python troubleshooting.py --auto-detect¬†para diagn√≥stico autom√°tico
Contacta al mantenedor: [tu-contacto@universidad.edu]
¬°Recuerda que cada ejecuci√≥n se guarda autom√°ticamente en la bit√°cora!¬†üìí
Etapa | Criterio de √âxito | Verificaci√≥n
1 | 3 modelos Ollama + entorno Python | ollama list¬†+¬†python --version
2 | NS-3 compila + hello-simulator funciona | ./ns3 run scratch/test_basic.py
3 | Agentes investigador/programador ejecutan | python run_basic.py
4 | Simulaci√≥n NS-3 ejecuta completa | python run_complete.py
5 | Reporte de an√°lisis generado | Ver archivos en¬†simulations/plots/
6 | Sistema automatizado funciona | ./start_system.sh test
7 | Caracter√≠sticas avanzadas integradas | Tests espec√≠ficos por caracter√≠stica
8 | Sistema en producci√≥n | GitHub Actions pasan + documentaci√≥n